import {
  AddressAutofillCore,
  SearchBoxCore,
  SearchSession,
  config,
  confirmAddress
} from "./chunk-5VYKKNNX.js";
import {
  require_react
} from "./chunk-6CE3F7YD.js";
import {
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@mapbox/search-js-react/dist/index-esm.js
var import_react = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var import_react5 = __toESM(require_react());
var import_react6 = __toESM(require_react());
var import_react7 = __toESM(require_react());
var import_react8 = __toESM(require_react());
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var AddressAutofill = import_react.default.forwardRef((props, refProp) => {
  const {
    accessToken,
    options,
    theme,
    popoverOptions,
    confirmOnBrowserAutofill,
    browserAutofillEnabled,
    children,
    onChange,
    onSuggest,
    onSuggestError,
    onRetrieve,
    interceptSearch
  } = props;
  const ref = (0, import_react.useRef)();
  (0, import_react.useImperativeHandle)(refProp, () => ({
    focus: () => {
      if (ref.current)
        return ref.current.focus();
      throw new Error("AddressAutofill is not mounted");
    }
  }));
  (0, import_react.useEffect)(() => {
    if (ref.current)
      ref.current.options = options;
  }, [ref.current, options]);
  (0, import_react.useEffect)(() => {
    if (ref.current)
      ref.current.interceptSearch = interceptSearch;
  }, [ref.current, options]);
  (0, import_react.useEffect)(() => {
    if (ref.current)
      ref.current.theme = theme;
  }, [ref.current, theme]);
  (0, import_react.useEffect)(() => {
    if (ref.current)
      ref.current.popoverOptions = popoverOptions;
  }, [ref.current, popoverOptions]);
  (0, import_react.useEffect)(() => {
    if (ref.current)
      ref.current.confirmOnBrowserAutofill = confirmOnBrowserAutofill;
  }, [ref.current, confirmOnBrowserAutofill]);
  (0, import_react.useEffect)(() => {
    if (ref.current)
      ref.current.browserAutofillEnabled = browserAutofillEnabled;
  }, [ref.current, browserAutofillEnabled]);
  (0, import_react.useEffect)(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onSuggest)
      return;
    const fn = (e) => onSuggest(e.detail);
    node.addEventListener("suggest", fn);
    return () => {
      node.removeEventListener("suggest", fn);
    };
  }, [ref.current, onSuggest]);
  (0, import_react.useEffect)(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onSuggestError)
      return;
    const fn = (e) => onSuggestError(e.detail);
    node.addEventListener("suggesterror", fn);
    return () => {
      node.removeEventListener("suggesterror", fn);
    };
  }, [ref.current, onSuggestError]);
  (0, import_react.useEffect)(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onRetrieve)
      return;
    const fn = (e) => onRetrieve(e.detail);
    node.addEventListener("retrieve", fn);
    return () => {
      node.removeEventListener("retrieve", fn);
    };
  }, [ref.current, onRetrieve]);
  (0, import_react.useEffect)(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onChange)
      return;
    const fn = (e) => {
      if (e.target !== e.currentTarget)
        return;
      onChange(e.detail);
    };
    node.addEventListener("input", fn);
    return () => {
      node.removeEventListener("input", fn);
    };
  }, [ref.current, onChange]);
  (0, import_react.useEffect)(() => {
    if (ref.current)
      ref.current.accessToken = accessToken;
  }, [ref.current, accessToken]);
  return import_react.default.createElement("mapbox-address-autofill", {
    ref
  }, children);
});
var SearchBox = import_react2.default.forwardRef((props, refProp) => {
  const {
    accessToken,
    options,
    theme,
    popoverOptions,
    map,
    value,
    onChange,
    onSuggest,
    onSuggestError,
    onRetrieve,
    interceptSearch
  } = props;
  const ref = (0, import_react2.useRef)();
  (0, import_react2.useImperativeHandle)(refProp, () => ({
    focus: () => {
      if (ref.current)
        return ref.current.focus();
      throw new Error("SearchBox is not mounted");
    }
  }));
  (0, import_react2.useEffect)(() => {
    if (ref.current)
      ref.current.options = options;
  }, [ref.current, options]);
  (0, import_react2.useEffect)(() => {
    if (ref.current)
      ref.current.interceptSearch = interceptSearch;
  }, [ref.current, options]);
  (0, import_react2.useEffect)(() => {
    if (ref.current)
      ref.current.theme = theme;
  }, [ref.current, theme]);
  (0, import_react2.useEffect)(() => {
    if (ref.current)
      ref.current.popoverOptions = popoverOptions;
  }, [ref.current, popoverOptions]);
  (0, import_react2.useEffect)(() => {
    if (ref.current)
      ref.current.value = value;
  }, [ref.current, value]);
  (0, import_react2.useEffect)(() => {
    const node = ref.current;
    if (!node)
      return;
    node.bindMap(map);
    return () => {
      node.unbindMap();
    };
  }, [ref.current, map]);
  (0, import_react2.useEffect)(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onSuggest)
      return;
    const fn = (e) => onSuggest(e.detail);
    node.addEventListener("suggest", fn);
    return () => {
      node.removeEventListener("suggest", fn);
    };
  }, [ref.current, onSuggest]);
  (0, import_react2.useEffect)(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onSuggestError)
      return;
    const fn = (e) => onSuggestError(e.detail);
    node.addEventListener("suggesterror", fn);
    return () => {
      node.removeEventListener("suggesterror", fn);
    };
  }, [ref.current, onSuggestError]);
  (0, import_react2.useEffect)(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onRetrieve)
      return;
    const fn = (e) => onRetrieve(e.detail);
    node.addEventListener("retrieve", fn);
    return () => {
      node.removeEventListener("retrieve", fn);
    };
  }, [ref.current, onRetrieve]);
  (0, import_react2.useEffect)(() => {
    const node = ref.current;
    if (!node)
      return;
    if (!onChange)
      return;
    const fn = (e) => {
      if (e.target !== e.currentTarget)
        return;
      onChange(e.detail);
    };
    node.addEventListener("input", fn);
    return () => {
      node.removeEventListener("input", fn);
    };
  }, [ref.current, onChange]);
  (0, import_react2.useEffect)(() => {
    if (ref.current)
      ref.current.accessToken = accessToken;
  }, [ref.current, accessToken]);
  return import_react2.default.createElement("mapbox-search-box", {
    ref
  });
});
function AddressMinimap(props) {
  const {
    canAdjustMarker = false,
    keepMarkerCentered = false,
    markerAnchor = "bottom",
    onSaveMarkerLocation,
    show = false,
    accessToken,
    feature = null,
    adjustBtnText,
    saveBtnText,
    cancelBtnText,
    satelliteToggle = false,
    theme,
    mapStyleMode = "default",
    defaultMapStyle = ["mapbox", "streets-v11"],
    footer
  } = props;
  const ref = (0, import_react3.useRef)();
  (0, import_react3.useEffect)(() => {
    if (!ref.current)
      return;
    if (show) {
      ref.current.show();
    } else {
      ref.current.hide();
    }
  }, [ref.current, show]);
  (0, import_react3.useEffect)(() => {
    if (ref.current)
      ref.current.theme = theme;
  }, [ref.current, theme]);
  (0, import_react3.useEffect)(() => {
    if (ref.current)
      ref.current.feature = show ? feature : null;
  }, [ref.current, feature, show]);
  (0, import_react3.useEffect)(() => {
    if (ref.current)
      ref.current.mapStyleMode = mapStyleMode;
  }, [ref.current, mapStyleMode]);
  (0, import_react3.useEffect)(() => {
    if (adjustBtnText === void 0)
      return;
    if (ref.current)
      ref.current.adjustBtnText = adjustBtnText;
  }, [ref.current, adjustBtnText]);
  (0, import_react3.useEffect)(() => {
    if (saveBtnText === void 0)
      return;
    if (ref.current)
      ref.current.saveBtnText = saveBtnText;
  }, [ref.current, saveBtnText]);
  (0, import_react3.useEffect)(() => {
    if (cancelBtnText === void 0)
      return;
    if (ref.current)
      ref.current.cancelBtnText = cancelBtnText;
  }, [ref.current, cancelBtnText]);
  (0, import_react3.useEffect)(() => {
    if (ref.current)
      ref.current.defaultMapStyle = defaultMapStyle;
  }, [ref.current, defaultMapStyle]);
  (0, import_react3.useEffect)(() => {
    if (footer === void 0)
      return;
    if (ref.current)
      ref.current.footer = footer;
  }, [ref.current, footer]);
  (0, import_react3.useEffect)(() => {
    if (ref.current)
      ref.current.accessToken = accessToken;
  }, [ref.current, accessToken]);
  (0, import_react3.useEffect)(() => {
    if (ref.current)
      ref.current.onSaveMarkerLocation = onSaveMarkerLocation;
  }, [ref.current, onSaveMarkerLocation]);
  return import_react3.default.createElement("mapbox-address-minimap", {
    ref,
    "can-adjust-marker": canAdjustMarker,
    "keep-marker-centered": keepMarkerCentered,
    "marker-anchor": markerAnchor,
    "satellite-toggle": satelliteToggle
  });
}
function useEvented(evented, eventName, cb) {
  const cbRef = (0, import_react4.useRef)(cb);
  (0, import_react4.useEffect)(() => {
    cbRef.current = cb;
  });
  (0, import_react4.useEffect)(() => {
    if (!evented)
      return;
    const fn = (object) => cbRef.current(object);
    evented.addEventListener(eventName, fn);
    return () => {
      evented.removeEventListener(eventName, fn);
    };
  }, [evented, eventName, cbRef]);
}
var DEFAULTS = AddressAutofillCore.defaults;
function useAddressAutofillCore(options) {
  const autofill = (0, import_react5.useMemo)(() => {
    return new AddressAutofillCore();
  }, []);
  (0, import_react5.useEffect)(() => {
    const _a = options, { accessToken } = _a, restOptions = __objRest(_a, ["accessToken"]);
    autofill.accessToken = accessToken;
    autofill.defaults = __spreadValues(__spreadValues({}, DEFAULTS), restOptions);
  }, [options]);
  return autofill;
}
var DEFAULTS2 = SearchBoxCore.defaults;
function useSearchBoxCore(options) {
  const search = (0, import_react6.useMemo)(() => {
    return new SearchBoxCore();
  }, []);
  (0, import_react6.useEffect)(() => {
    const _a = options, { accessToken } = _a, restOptions = __objRest(_a, ["accessToken"]);
    search.accessToken = accessToken;
    search.defaults = __spreadValues(__spreadValues({}, DEFAULTS2), restOptions);
  }, [options]);
  return search;
}
function useSearchSession(search) {
  const searchSession = (0, import_react7.useMemo)(() => {
    return new SearchSession(search);
  }, [search]);
  if (search instanceof SearchBoxCore) {
    return searchSession;
  } else {
    return searchSession;
  }
}
function useConfirmAddress(optionsArg = {}) {
  const formRef = (0, import_react8.useRef)(null);
  return (0, import_react8.useMemo)(() => {
    return {
      formRef,
      showConfirm: () => confirmAddress(formRef.current, optionsArg)
    };
  }, [formRef, optionsArg]);
}
export {
  AddressAutofill,
  AddressMinimap,
  SearchBox,
  config,
  useAddressAutofillCore,
  useConfirmAddress,
  useEvented,
  useAddressAutofillCore as useMapboxAutofill,
  useSearchBoxCore,
  useSearchSession
};
//# sourceMappingURL=@mapbox_search-js-react.js.map
